{
  "entities": {
    "User": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "User",
      "type": "object",
      "description": "Represents a user in the LearnTogether application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the User entity."
        },
        "displayName": {
          "type": "string",
          "description": "The user's display name."
        },
        "avatarSeed": {
          "type": "string",
          "description": "Seed used to generate the user's avatar."
        },
        "createdAt": {
          "type": "number",
          "description": "Timestamp of when the user was created."
        }
      },
      "required": [
        "id",
        "displayName",
        "avatarSeed",
        "createdAt"
      ]
    },
    "Channel": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Channel",
      "type": "object",
      "description": "Represents a channel in the LearnTogether application.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Channel entity."
        },
        "name": {
          "type": "string",
          "description": "The name of the channel."
        },
        "createdBy": {
          "type": "string",
          "description": "Reference to User who created the channel. (Relationship: User 1:N Channel)"
        },
        "createdAt": {
          "type": "number",
          "description": "Timestamp of when the channel was created."
        },
        "members": {
          "type": "array",
          "description": "List of user IDs who are members of this channel.",
          "items": {
            "type": "string"
          }
        },
        "currentTrackUrl": {
          "type": "string",
          "description": "URL of the currently playing track in the channel."
        },
        "currentTrackRequestedBy": {
          "type": "string",
          "description": "Reference to User who requested the current track. (Relationship: User 1:N Channel)"
        },
        "isPlaying": {
          "type": "boolean",
          "description": "Indicates whether the current track is playing."
        },
        "updatedAt": {
          "type": "number",
          "description": "Timestamp of when the current track was last updated."
        }
      },
      "required": [
        "id",
        "name",
        "createdBy",
        "createdAt"
      ]
    },
    "Message": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "Message",
      "type": "object",
      "description": "Represents a message in a channel.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the Message entity."
        },
        "channelId": {
          "type": "string",
          "description": "Reference to Channel that the message belongs to. (Relationship: Channel 1:N Message)"
        },
        "userId": {
          "type": "string",
          "description": "Reference to User who sent the message. (Relationship: User 1:N Message)"
        },
        "text": {
          "type": "string",
          "description": "The text content of the message."
        },
        "type": {
          "type": "string",
          "description": "The type of message (text or youtube)."
        },
        "createdAt": {
          "type": "number",
          "description": "Timestamp of when the message was created."
        }
      },
      "required": [
        "id",
        "channelId",
        "userId",
        "text",
        "type",
        "createdAt"
      ]
    },
    "MusicSuggestion": {
      "$schema": "http://json-schema.org/draft-07/schema#",
      "title": "MusicSuggestion",
      "type": "object",
      "description": "Represents a music suggestion generated by the GenAI tool.",
      "properties": {
        "id": {
          "type": "string",
          "description": "Unique identifier for the MusicSuggestion entity."
        },
        "channelId": {
          "type": "string",
          "description": "Reference to the channel the suggestion is for. (Relationship: Channel 1:N MusicSuggestion)"
        },
        "suggestedByUserId": {
          "type": "string",
          "description": "Reference to the user who requested the music suggestion. (Relationship: User 1:N MusicSuggestion)"
        },
        "musicUrl": {
          "type": "string",
          "description": "URL of the suggested music track."
        },
        "reason": {
          "type": "string",
          "description": "Reason why this music was suggested (e.g., based on listening history)."
        },
        "createdAt": {
          "type": "number",
          "description": "Timestamp of when the suggestion was generated."
        }
      },
      "required": [
        "id",
        "channelId",
        "suggestedByUserId",
        "musicUrl",
        "reason",
        "createdAt"
      ]
    }
  },
  "auth": {
    "providers": [
      "password",
      "anonymous"
    ]
  },
  "firestore": {
    "structure": [
      {
        "path": "/users/{userId}",
        "definition": {
          "entityName": "User",
          "schema": {
            "$ref": "#/backend/entities/User"
          },
          "description": "Stores user profiles.  Accessible only to the user themselves (path-based ownership).",
          "params": [
            {
              "name": "userId",
              "description": "The unique identifier of the user."
            }
          ]
        }
      },
      {
        "path": "/channels/{channelId}",
        "definition": {
          "entityName": "Channel",
          "schema": {
            "$ref": "#/backend/entities/Channel"
          },
          "description": "Stores channel information. Includes a 'members' map for authorization independence.",
          "params": [
            {
              "name": "channelId",
              "description": "The unique identifier of the channel."
            }
          ]
        }
      },
      {
        "path": "/channels/{channelId}/messages/{messageId}",
        "definition": {
          "entityName": "Message",
          "schema": {
            "$ref": "#/backend/entities/Message"
          },
          "description": "Stores messages within a channel.  Authorization is implicitly linked to channel membership (path-based).",
          "params": [
            {
              "name": "channelId",
              "description": "The unique identifier of the channel."
            },
            {
              "name": "messageId",
              "description": "The unique identifier of the message."
            }
          ]
        }
      },
      {
        "path": "/channels/{channelId}/musicSuggestions/{musicSuggestionId}",
        "definition": {
          "entityName": "MusicSuggestion",
          "schema": {
            "$ref": "#/backend/entities/MusicSuggestion"
          },
          "description": "Stores music suggestions for a channel. Authorization is linked to channel membership (path-based).  May include a denormalized `members` map for authorization independence if required by rules.",
          "params": [
            {
              "name": "channelId",
              "description": "The unique identifier of the channel."
            },
            {
              "name": "musicSuggestionId",
              "description": "The unique identifier of the music suggestion."
            }
          ]
        }
      }
    ],
    "reasoning": "The Firestore structure is designed to prioritize authorization independence, clarity, and scalability for the SyncStream application.  \n\n**Authorization Independence:**\nTo avoid hierarchical authorization dependencies and enable atomic operations, key authorization data is denormalized. Specifically:\n\n*   `channels/{channelId}`: The `members` map, containing user IDs and roles, is crucial for determining access to the channel and is included directly in the channel document.\n*   `channels/{channelId}/messages/{messageId}`: While ownership is path-based, the design can be extended to denormalize relevant channel membership data into each message document if needed for more complex authorization scenarios in the future.  For example, storing the `members` map on each message would enable rules to validate message content based on the sender's role in the channel without requiring a `get()` call to the parent channel.\n*   `channels/{channelId}/musicSuggestions/{musicSuggestionId}`: Same as messages, ownership is primarily managed via the path.  If the rules require access to the channel's member list from the suggestion, the suggestion document should include a denormalized copy of the `members` map from the parent channel document.\n\n**Structural Segregation:**\nThe structure segregates data based on its security posture:\n\n*   `/users/{userId}`: User profiles are private and accessible only to the user themselves.\n*   `/channels/{channelId}`: Channels are collaborative spaces with access controlled by the `members` map.\n\n**Access Modeling:**\nConsistent access patterns are used throughout the structure:\n\n*   **Path-Based Ownership:**  User profiles (`/users/{userId}`) utilize path-based ownership.\n*   **Membership Map:** Channels (`/channels/{channelId}`) use the `members` map for collaborative access control.  This map stores user IDs as keys, allowing for easy role management.\n\n**QAPs (Rules are not Filters):**\nThe structure supports secure list operations:\n\n*   Listing channels requires no filtering on the client-side. Security rules can efficiently validate access based on the `members` map in each channel document, ensuring users only see channels they have access to.\n*   Similarly, listing messages within a channel is secured by rules that verify the user's membership in the channel before allowing access to the messages subcollection.\n\n**Invariants:**\nThe structure enables the enforcement of data integrity:\n\n*   Ownership: Path-based ownership for user profiles ensures that only the user can modify their data.\n*   Timestamps:  `createdAt` fields are used consistently across entities, enabling rules to enforce the immutability of creation timestamps.\n*   Denormalized Data: Security rules can validate that the denormalized `members` map in subcollections remains consistent with the parent channel document.\n\nThis structure promotes simple, robust, and easily debuggable security rules by minimizing the need for complex logic and `get()` calls, enabling efficient and secure data access patterns."
  }
}